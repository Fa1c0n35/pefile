#summary Usage examples of pefile

= Introduction =

Simple code snippets to get you started

== Loading a PE file ==

Import the module and parse a file.
{{{
import pefile
pe =  pefile.PE(‘/path/to/pefile.exe’)
}}}

Optionally, setting the _fast_load_ argument to _True_ will prevent parsing the directories. In large PE files this can make loading significantly faster and it might be a good idea to use it none of the information from the data directories is needed.

{{{
import pefile
pe =  pefile.PE(‘/path/to/pefile.exe’, fast_load=True)
}}}

A later call to the _full_load()_ method would parse the missing information.


It's also possible to just parse raw PE data:

{{{
pe = pefile.PE(data=str_object_with_pe_file_data)
}}}



== Reading standard header members ==

Once the PE file is successfully parsed, the data is readily available as attributes of the PE instance.

{{{
pe.OPTIONAL_HEADER.AddressOfEntryPoint
pe.OPTIONAL_HEADER.NumberOfSections
pe.OPTIONAL_HEADER.ImageBase
}}}

All of these values support assignment and a subsequent call to

{{{
pe.write(filename='file_to_write.exe')
}}}

will write the modified file to disk.

All the structures and members defined in the PE format should be available with the same names. Some convenient shortcuts exist, for instance the _sections_ list. Usually, all the structures containing a member _Characteristics_ (or similar fields of flags) will contain attributes set to _True_ or _False_ according to the value of the corresponding flag.


== Iterating through the sections ==

Sections are added to a list accesible as the attribute _sections_ in the PE instance.
The common structure members of the section header are reachable as attributes.

{{{
for section in pe.sections:
  print (section.Name, hex(section.VirtualAddress),
    hex(section.Misc_VirtualSize), section.SizeOfRawData )
}}}


=== Output ===

{{{
('.text', '0x1000L', '0x6D72L', 28160L)
('.data', '0x8000L', '0x1BA8L', 1536L)
('.rsrc', '0xA000L', '0x8948L', 35328L)
}}}


== Listing the imported symbols ==

Each directory, if it exists in the PE file being processed, has an entry as _DIRECTORY_ENTRY_directoryname_ in the PE instance. The imported symbols can be listed as follows:

{{{
for entry in pe.DIRECTORY_ENTRY_IMPORT:
  print entry.dll
  for imp in entry.imports:
    print '\t', hex(imp.address), imp.name
}}}


=== Output ===

{{{
comdlg32.dll
        0x10012A0L PageSetupDlgW
        0x10012A4L FindTextW
        0x10012A8L PrintDlgExW
[snip]
SHELL32.dll
        0x1001154L DragFinish
        0x1001158L DragQueryFileW
}}}


== Listing the exported symbols ==

Similarly, the exported symbols can be listed as follows:

{{{
for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
  print hex(pe.OPTIONAL_HEADER.ImageBase + exp.address), exp.name
}}}


=== Output ===

{{{
0x77e72ada ActivateActCtx
0x77e682c2 AddAtomA
0x77e6d39f AddAtomW
0x77ec5b2d AddConsoleAliasA
0x77ec5af6 AddConsoleAliasW
0x77eb2a10 AddLocalAlternateComputerNameA
0x77eb28fb AddLocalAlternateComputerNameW
0x77ec0ffa AddRefActCtx
}}}


== Dumping all the information ==

{{{
print pe.dump_info()
}}}

Will produce a full textial dump of all the parsed information. Check FullDump0x90, [FullDumpTinyPE] or FullDumpKernel32 for examples.


== Retrieving the bytes at the entry point ==

We can use _pefile_ together with tools like [http://dkbza.org/pydasm.html pydasm] to build a small disassembler. A toy example might look like the following.

We first fetch the entry point address, the retrieve 100 bytes starting at the entry point and we loop through the data disassembling as we go:

{{{
ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
ep_ava = ep+pe.OPTIONAL_HEADER.ImageBase
data = pe.get_memory_mapped_image()[ep:ep+100]
offset = 0
while offset < len(data):
  i = pydasm.get_instruction(data[offset:], pydasm.MODE_32)
  print pydasm.get_instruction_string(i, pydasm.FORMAT_INTEL, ep_ava+offset)
  offset += i.length
}}}


=== Output ===

{{{
push byte 0x70
push dword 0x1001888
call 0x1006ca8
xor ebx,ebx
push ebx
mov edi,[0x100114c]
call edi
cmp word [eax],0x5a4d
jnz 0x1006b1d
mov ecx,[eax+0x3c]
add ecx,eax
cmp dword [ecx],0x4550
jnz 0x1006b1d
movzx eax,[ecx+0x18
}}}